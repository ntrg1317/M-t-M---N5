\subsection{DES (Data Encryption Standard)}
\subsubsection{Hàm tạo khoá vòng}
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	void generate_keys(string key) {
		int PC_1[56] = {
			57,49,41,33,25,17,9, 
			1,58,50,42,34,26,18, 
			10,2,59,51,43,35,27, 
			19,11,3,60,52,44,36,		 
			63,55,47,39,31,23,15, 
			7,62,54,46,38,30,22, 
			14,6,61,53,45,37,29, 
			21,13,5,28,20,12,4 
		};
		
		int PC_2[48] = {
			14,17,11,24,1,5, 
			3,28,15,6,21,10, 
			23,19,12,4,26,8, 
			16,7,27,20,13,2, 
			41,52,31,37,47,55, 
			30,40,51,45,33,48, 
			44,49,39,56,34,53, 
			46,42,50,36,29,32 
		};
		
		// Hoán vị key theo bảng pc_1
		string perm_key = "";
		for(int i = 0; i < 56; i++) {
			perm_key += key[PC_1[i] - 1];
		}
		
		// Xác định giá trị C0 và D0
		string C = perm_key.substr(0, 28);
		string D = perm_key.substr(28, 28);
		
		for(int i = 0; i < 16; i++) {
			// Lần lặp thứ 1, 2, 9, 16 dịch trái 1 lần; những vị trí còn lại dịch trái 2 lần
			if (i == 0 || i == 1 || i == 8 || i == 15) {
				C = shift_left_once(C);
				D = shift_left_once(D);
			} else {
				C = shift_left_twice(C);
				D = shift_left_twice(D);
			}
			
			string combined_key = C + D;
			
			string round_key = "";
			for(int j = 0; j < 48; j++) {
				round_key += combined_key[PC_2[j] - 1];
			}
			round_keys[i] = round_key; 
		}
	}
\end{minted}
\subsubsection{Hàm tính \(f(R, K)\)}
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	string f(string R, string round_key) {
		int E[48] = {
			32,1,2,3,4,5,4,5, 
			6,7,8,9,8,9,10,11, 
			12,13,12,13,14,15,16,17, 
			16,17,18,19,20,21,20,21, 
			22,23,24,25,24,25,26,27, 
			28,29,28,29,30,31,32,1
		};
		
		// Hàm S-box
		int S[8][4][16] = 
		{{ 
				14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7, 
				0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8, 
				4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0, 
				15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13 
			}, 
			{ 
				15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10, 
				3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5, 
				0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15, 
				13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9 
			}, 
			{ 
				10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8, 
				13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1, 
				13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7, 
				1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12 
			}, 
			{ 
				7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15, 
				13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9, 
				10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4, 
				3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14 
			}, 
			{ 
				2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9, 
				14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6, 
				4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14, 
				11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3 
			}, 
			{ 
				12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11, 
				10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8, 
				9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6, 
				4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13 
			}, 
			{ 
				4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1, 
				13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6, 
				1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2, 
				6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12 
			}, 
			{ 
				13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7, 
				1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2, 
				7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8, 
				2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11 
		}};
		
		int P[32] = { 
			16,7,20,21,29,12,28,17, 
			1,15,23,26,5,18,31,10, 
			2,8,24,14,32,27,3,9,
			19,13,30,6,22,11,4,25 
		}; 
		
		// Hoán vị R
		string RE = "";
		for(int i = 0; i < 48; i++) {
			RE += R[E[i] - 1];
		}
		
		string xored = XOR(RE, round_key);
		string res = "";
		for(int i = 0; i < 8; i++) {
			string row_bin = xored.substr(i * 6, 1) + xored.substr(i * 6 + 5, 1);
			int row = convertBintoDec(row_bin);
			string col_bin = xored.substr(i * 6 + 1, 1) + xored.substr(i * 6 + 2, 1) + xored.substr(i * 6 + 3, 1) + xored.substr(i * 6 + 4, 1);
			int col = convertBintoDec(col_bin);
			
			int val = S[i][row][col];
			res += convertDectoBin(val);
		}
		
		string f = "";
		for(int i = 0; i < 32; i++) {
			f += res[P[i] - 1];
		}
		return f;
	}
\end{minted}

\subsubsection{Hàm DES}
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	string DES(string plain_text) {
		int IP[64] = {
			58,50,42,34,26,18,10,2, 
			60,52,44,36,28,20,12,4, 
			62,54,46,38,30,22,14,6, 
			64,56,48,40,32,24,16,8, 
			57,49,41,33,25,17,9,1, 
			59,51,43,35,27,19,11,3, 
			61,53,45,37,29,21,13,5, 
			63,55,47,39,31,23,15,7
		};
		
		int inverse_IP[64] = {
			40,8,48,16,56,24,64,32, 
			39,7,47,15,55,23,63,31, 
			38,6,46,14,54,22,62,30, 
			37,5,45,13,53,21,61,29, 
			36,4,44,12,52,20,60,28, 
			35,3,43,11,51,19,59,27, 
			34,2,42,10,50,18,58,26, 
			33,1,41,9,49,17,57,25 
		};
		
		int E[48] = {
			32,1,2,3,4,5,4,5, 
			6,7,8,9,8,9,10,11, 
			12,13,12,13,14,15,16,17, 
			16,17,18,19,20,21,20,21, 
			22,23,24,25,24,25,26,27, 
			28,29,28,29,30,31,32,1
		};
		
		
		// Thực hiện hoán vị bản rõ
		string permutation = "";
		for(int i = 0; i < 64; i++) {
			permutation += plain_text[IP[i] - 1];
		}
		
		string L = permutation.substr(0, 32);
		string R = permutation.substr(32, 32);
		
		for(int i = 0; i < 16; i++) {
			string xored1 = XOR(L, f(R, round_keys[i]));
			L = xored1;
			if (i < 15) {
				string temp = R;
				R = xored1;
				L = temp;
			}
		}
		
		string combined_text = L + R;
		string ciphertext =""; 
		// Áp dụng bảng hoán vị IP-1
		for(int i = 0; i < 64; i++){ 
			ciphertext += combined_text[inverse_IP[i] - 1]; 
		}
		
		return ciphertext;
	}
\end{minted}

\subsubsection{Hàm encrypt}
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	void encrypt() {
		string plain_text;
		string key;
		system("cls");
		cout << "Nhap ban ro (16 ki tu): ";
		do {
			cin >> plain_text;
			if (!is_valid(plain_text, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(plain_text, 16));
		
		cout << "Nhap khoa (16 ki tu): ";
		do {
			cin >> key;
			if (!is_valid(key, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(key, 16));
		
		generate_keys(convertHextoBin(key));
		
		string ciphertext = DES(convertHextoBin(plain_text));
		cout <<  "Ban ro: " << plain_text << endl;
		cout << "Ban ma: " << convertBintoHex(ciphertext) << endl;
	}
\end{minted}
\subsubsection{Hàm decrypt}
Hàm decrypt được thực hiện tương tự encrypt tuy nhiên, mảng khoá vòng được đảo chiều lại.
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	void decrypt() {
		string ciphertext;
		string key;
		system("cls");
		
		cout << "Nhap ban ma (16 ki tu): ";
		do {
			cin >> ciphertext;
			if (!is_valid(ciphertext, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(ciphertext, 16));
		
		cout << "Nhap khoa (16 ki tu): ";
		do {
			cin >> key;
			if (!is_valid(key, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(key, 16));
		
		
		generate_keys(convertHextoBin(key));
		
		
		int i = 15;
		int j = 0;
		while(i > j)
		{
			string temp = round_keys[i];
			round_keys[i] = round_keys[j];
			round_keys[j] = temp;
			i--;
			j++;
		}
		
		string plaintext = DES(convertHextoBin(ciphertext));
		cout << "Ban ma: " << ciphertext << endl;
		cout << "Ban ro: " << convertBintoHex(plaintext) << endl;
	} 
\end{minted}
\subsection{AES (Advanced Encryption Standard)}
\subsubsection{Các hàm phụ}
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	unsigned int RotWord(unsigned int w)
	{
		//Dich vong trai 1 byte
		unsigned int byte1 = (w >> 24) & 0xff;
		unsigned int byte234 = w & 0xffffff;
		unsigned int rot = (byte234 << 8) | byte1;
		return rot;
	}
	
	unsigned int SubWord(unsigned int w)
	{
		int S[] = {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 
			0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 
			0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 
			0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 
			0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 
			0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 
			0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 
			0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 
			0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 
			0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 
			0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 
			0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 
			0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 
			0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 
			0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 
			0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
		};
		unsigned int kq = 0;
		for(int i = 1; i <= 4; i++)	
		{
			unsigned int bytei = (w >> (32 - i*8)) & 0xff;
			unsigned int subB = S[bytei];
			kq = (kq << 8) | subB;
		}
		//printf("\n\tSubWord(%X) = ",w); ShowWord(kq);
		return kq;
	}
	
	unsigned int XorRcon(unsigned int w, int j)
	{     
		int Rc[] = {
			0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
			0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39
		};
		unsigned int byte1 = (w >> 24) & 0xff;
		unsigned int kqXor = (byte1 ^ Rc[j]) & 0xff;
		unsigned int byte234 = w & 0xffffff;
		unsigned int kq = (kqXor << 24) | byte234;
		
		return kq;
	}
	
	unsigned int Trans(unsigned int w, int j)
	{
		unsigned int rotW = RotWord(w);
		unsigned int subW = SubWord(rotW);
		unsigned int kq = XorRcon(subW, j);
		return kq;
	}
	
	unsigned int* KeyExpansion(unsigned int Key[4])
	{
		unsigned int *w = new unsigned int[44];
		w[0] = Key[0]; 	
		w[1] = Key[1]; 	
		w[2] = Key[2]; 	
		w[3] = Key[3];
		for(int i = 4; i < 44; i++)
		{
			if(i % 4 == 0) w[i] = Trans(w[i - 1], i/4) ^ w[i - 4];
			else w[i] = w[i - 1] ^ w[i - 4];
		}
		return w;
	}
\end{minted}
\subsubsection{Mã hoá}
\begin{enumerate}
	\item Hàm AddRoundKey()
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int* AddRoundKey(unsigned int state[4], unsigned int *K)
		{
			unsigned int *kq = new unsigned int[4];
			kq[0] = state[0] ^ K[0];
			kq[1] = state[1] ^ K[1];
			kq[2] = state[2] ^ K[2];
			kq[3] = state[3] ^ K[3];
			
			return kq;
		}
	\end{minted}
	\item Hàm SubBytes()
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int* SubBytes(unsigned int state[4])
		{
			unsigned int *kq = new unsigned int[4];
			for (int i = 0; i < 4; i++){
				kq[i] = SubWord(state[i]);
			}
			
			return kq;
		}
	\end{minted}
	\item Hàm ShiftRows()
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int* ShiftRows(unsigned int state[4])
		{
			unsigned int *kq = new unsigned int[4];
			for (int i = 0; i < 4; i++)
			{
				unsigned int byte1 = state[i] & 0xff000000;
				unsigned int byte2 = state[(i + 1) % 4] & 0xff0000;
				unsigned int byte3 = state[(i + 2) % 4] & 0xff00;
				unsigned int byte4 = state[(i + 3) % 4] & 0xff;
				
				kq[i] = byte1 | byte2 | byte3 | byte4;
			}
			return kq;
		}
	\end{minted}
	\item Hàm MixColumns()
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int Nhan2(unsigned int w)
		{
			unsigned int kq = w << 1;
			if(kq > 256) kq = kq ^ 0x11b;
			kq = kq & 0xFF;
			return kq;
		}
		
		unsigned int Nhan3(unsigned int w)
		{
			unsigned int kq = w ^ Nhan2(w);
			kq = kq & 0xFF;
			return kq;
		}
		
		unsigned int NhanCot(unsigned int w)
		{
			unsigned int kq;
			unsigned int byte1 = (w >> 24) & 0xFF;
			unsigned int byte2 = (w >> 16) & 0xFF;
			unsigned int byte3 = (w >> 8) & 0xFF;
			unsigned int byte4 = w & 0xFF;
			unsigned int kq1 = Nhan2(byte1) ^ Nhan3(byte2) ^ byte3 ^ byte4;
			unsigned int kq2 = byte1 ^ Nhan2(byte2) ^ Nhan3(byte3) ^ byte4;
			unsigned int kq3 = byte1 ^ byte2 ^ Nhan2(byte3) ^ Nhan3(byte4);
			unsigned int kq4 = Nhan3(byte1) ^ byte2 ^ byte3 ^ Nhan2(byte4);
			kq = (kq1 << 24) | (kq2 << 16) | (kq3 << 8) | kq4;
			//cout << "\n\t"; ShowWord(kq);
			return kq;
		}
		unsigned int* MixColumns(unsigned int state[4])
		{
			unsigned int *kq = new unsigned int[4];
			for (int i = 0; i < 4; i++) kq[i] = NhanCot(state[i]);
			
			return kq;
		}
	\end{minted}
\end{enumerate}

\subsubsection{Giải mã}
\begin{enumerate}
	\item Hàm InvSubBytes()
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int* InvSubBytes(unsigned int state[4])
		{
			unsigned int *kq = new unsigned int[4];
			for (int i = 0; i < 4; i++) kq[i] = InvSubWord(state[i]);
			return kq;
		}
	\end{minted}
	\item Hàm InvShiftRows()
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int* InvShiftRows(unsigned int state[4])
		{
			unsigned int *kq = new unsigned int[4];
			for (int i = 0; i < 4; i++)
			{
				unsigned int byte1 = state[i] & 0xff000000;
				unsigned int byte2 = state[(i + 3) % 4] & 0xff0000;
				unsigned int byte3 = state[(i + 2) % 4] & 0xff00;
				unsigned int byte4 = state[(i + 1) % 4] & 0xff; 
				
				kq[i] = byte1 | byte2 | byte3 | byte4;
			}
			return kq;
		}
	\end{minted}
	\item Hàm MixColumns()
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int Nhan9(unsigned int w)
		{
			unsigned int kq = (w << 3) ^ w;
			if(kq > (256 << 2)) kq = kq ^ (0x11b << 2);
			if(kq > (256 << 1)) kq = kq ^ (0x11b << 1);
			if (kq > 256) kq = kq ^ 0x11b;
			
			kq = kq & 0xFF;
			return kq;
		}
		
		unsigned int NhanB(unsigned int w)
		{
			unsigned int kq = (w << 3) ^ (w << 1) ^ w;
			if(kq > (256 << 2)) kq = kq ^ (0x11b << 2);
			if(kq > (256 << 1)) kq = kq ^ (0x11b << 1);
			if (kq > 256) kq = kq ^ 0x11b;
			
			kq = kq & 0xFF;
			return kq;
		}
		
		unsigned int NhanD(unsigned int w)
		{
			unsigned int kq = (w << 3) ^ (w << 2) ^ w;
			if(kq > (256 << 2)) kq = kq ^ (0x11b << 2);
			if(kq > (256 << 1)) kq = kq ^ (0x11b << 1);
			if (kq > 256) kq = kq ^ 0x11b;
			
			kq = kq & 0xFF;
			return kq;
		}
		
		unsigned int NhanE(unsigned int w)
		{
			unsigned int kq = (w << 3) ^ (w << 2) ^ (w << 1);
			if(kq > (256 << 2)) kq = kq ^ (0x11b << 2);
			if(kq > (256 << 1)) kq = kq ^ (0x11b << 1);
			if (kq > 256) kq = kq ^ 0x11b;
			
			kq = kq & 0xFF;
			return kq;
		}
		
		unsigned int InvNhanCot(unsigned int w)
		{
			unsigned int kq;
			unsigned int byte1 = (w >> 24) & 0xFF;
			unsigned int byte2 = (w >> 16) & 0xFF;
			unsigned int byte3 = (w >> 8) & 0xFF;
			unsigned int byte4 = w & 0xFF;
			unsigned int kq1 = NhanE(byte1) ^ NhanB(byte2) ^ NhanD(byte3) ^ Nhan9(byte4);
			unsigned int kq2 = Nhan9(byte1) ^ NhanE(byte2) ^ NhanB(byte3) ^ NhanD(byte4);
			unsigned int kq3 = NhanD(byte1) ^ Nhan9(byte2) ^ NhanE(byte3) ^ NhanB(byte4);
			unsigned int kq4 = NhanB(byte1) ^ NhanD(byte2) ^ Nhan9(byte3) ^ NhanE(byte4);
			
			kq = (kq1 << 24) | (kq2 << 16) | (kq3 << 8) | kq4;
			return kq;
		}
		
		unsigned int* InvMixColumns(unsigned int state[4])
		{
			unsigned int *kq = new unsigned int[4];
			for (int i = 0; i < 4; i++) 
			kq[i] = InvNhanCot(state[i]);
			return kq;
		}
	\end{minted}
	\item Hàm Giải mã
	\begin{minted}[mathescape,
		numbersep=5pt,
		frame=lines,
		framesep=2mm,
		breaklines,
		baselinestretch=1.2,
		bgcolor=LightGray,
		fontsize=\footnotesize,
		linenos]{C++}
		unsigned int* GiaimaAES(unsigned int C[4], unsigned int key[4])
		{
			unsigned int *w = KeyExpansion(key);
			unsigned int *state = AddRoundKey(C, &w[40]); 
			
			for(int j = 1; j <= 9; j++)
			{
				state = InvShiftRows(state);
				state = InvSubBytes(state);
				state = AddRoundKey(state, &w[40 - 4*j]);
				state = InvMixColumns(state);
			}
			
			//Vong thu 10
			state = InvShiftRows(state);
			state = InvSubBytes(state);
			state = AddRoundKey(state, &w[0]); 
			return state;
		}
	\end{minted}
\end{enumerate}
\subsection{Brute-Force}
\subsubsection{Hàm tăng dãy hex}
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	string nextHEX(string s) {
		int length = s.length();
		int carry = 1; // Biến nhớ để tăng số
		
		// Duyệt từ phải sang trái của chuỗi HEX
		for (int i = length - 1; i >= 0; i--) {
			int digit;
			if (s[i] >= '0' && s[i] <= '9') {
				digit = s[i] - '0';
			} else if (s[i] >= 'a' && s[i] <= 'f') {
				digit = s[i] - 'a' + 10;
			} else if (s[i] >= 'A' && s[i] <= 'F') {
				digit = s[i] - 'A' + 10;
			} else {
				cout << "Chuỗi nhập vào không hợp lệ!\n";
				return s;
			}
			
			digit += carry;
			if (digit >= 16) {
				digit -= 16;
				carry = 1; // Tiếp tục tăng số ở vị trí cao hơn
			} else {
				carry = 0; // Không cần tăng số ở vị trí cao hơn
			}
			
			if (digit < 10) {
				s[i] = '0' + digit;
			} else {
				s[i] = 'a' + (digit - 10);
			}
		}
		
		// Nếu carry vẫn còn, chúng ta cần thêm '1' vào đầu chuỗi
		if (carry) {
			s.insert(s.begin(), '1');
		}
		
		return s;
	}
\end{minted}
\subsubsection{Hàm thực hiện brute-force}
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	void bruteforce() {
		bool found ;
		string plain_text ; 
		string ciphertext;
		string key ;  
		string keyleft;
		string keyright;
		int count = 0 ;
		string Key[1000] ;
		system("cls");
		cout << "Nhap ban ro (16 ki tu): ";
		do {
			cin >> plain_text;
			if (!is_valid(plain_text, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(plain_text, 16));
		
		cout << "Nhap ban ma (16 ki tu): ";
		do {
			cin >> ciphertext;
			if (!is_valid(ciphertext, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(ciphertext, 16));
		
		cout << "Nhap khoang cua khoa da biet gom 2 chuoi 16 ky tu theo thu tu tang:\n" ;
		cout << "Khoa trai (16 ky tu): ";
		do {
			cin >> keyleft;
			if (!is_valid(keyleft, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(keyleft, 16));
		
		cout << "Khoa phai (16 ky tu): " ;
		do {
			cin >> keyright;
			if (!is_valid(keyright, 16))
			cout << "Moi ban nhap lai ban ro : ";
		} while (!is_valid(keyright, 16));
		
		key = keyleft ;
		found = false ;
		
		do  { 
			cout << "Key: " << key << endl;
			
			generate_keys(convertHextoBin(key)) ; 
			cout << "Ban ma: " << convertBintoHex(DES(convertHextoBin(plain_text))) << endl ;
			if(DES(convertHextoBin(plain_text)) == convertHextoBin(ciphertext)){
				found = true ;
				count++ ;
				Key[count] = key ;
			}
			key = nextHEX (key) ;
			
		} 
		while (key != keyright) ;
		if (found == false) {
			cout << "Khong tim thay khoa!" ;
		}
		if(found == true) 
		{
			cout << "Tim duoc " << count << " khoa duoi day: " << endl ;
			for(int i=1; i<=count; i++)
			{
				cout << Key[i] << endl ;
			}
		}
	}
\end{minted}
\subsection{Hàm main}
Hàm main chứa các menu lựa chọn thuật toán DES, AES để mã hoá và Brute-Force để tìm ra khoá (giả sử biết bản rõ, bản mã và khoảng giá trị của khoá do hạn chế thời gian chạy)
\begin{minted}[mathescape,
	numbersep=5pt,
	frame=lines,
	framesep=2mm,
	breaklines,
	baselinestretch=1.2,
	bgcolor=LightGray,
	fontsize=\footnotesize,
	linenos]{C++}
	#include <iostream>
	#include <windows.h>
	#include <conio.h>
	#include "AES.cpp"
	#include "DES.cpp"
	using namespace std;
	
	void mainpage(); // menu chính
	void menu1(); // menu phụ DES
	void menu2(); // menu phụ AES
	
	void gotoXY(int column, int line)
	{
		COORD coord;
		coord.X = column;
		coord.Y = line;
		SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
	}
	
	void box(int x, int y, int w, int h, int t_color, int f_color, string content)
	{
		for (int iy = y + 1; iy < y + h; iy++)
		{
			for (int ix = x + 1; ix < x + w; ix++)
			{
				gotoXY(ix, iy);
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), f_color);
				cout << " ";
			}
		}
		
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), t_color);
		if (h <= 1 || w <= 1)
		return;
		for (int ix = x; ix <= x + w; ix++)
		{
			gotoXY(ix, y);
			cout << char(196);
			gotoXY(ix, y + h);
			cout << char(196);
		}
		for (int iy = y; iy <= y + h; iy++)
		{
			gotoXY(x, iy);
			cout << char(179);
			gotoXY(x + w, iy);
			cout << char(179); 
		}
		gotoXY(x, y);
		cout << char(218);
		gotoXY(x + w, y);
		cout << char(191); 
		gotoXY(x, y + h);
		cout << char(192); 
		gotoXY(x + w, y + h);
		cout << char(217); 
		
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), f_color);
		int contentX = x + w / 2 - content.length() / 2;
		int contentY = y + h / 2;
		gotoXY(contentX, contentY);
		cout << content;
		
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); // Đặt lại màu về mặc định
	}
	
	
	void mainpage()
	{
		system("cls");
		
		const int MENU_SIZE = 4;
		bool selected[MENU_SIZE] = {false};
		int selectedIndex = 0;
		
		// Tạo mảng chứa thông tin về các lựa chọn trong menu
		string options[MENU_SIZE] = {" 1. DES", 
			" 2. AES", 
			" 3. Brute-Force", 
			" 0. Exit"};
		
		while (true)
		{
			// Vẽ menu với các lựa chọn
			for (int i = 0; i < MENU_SIZE; i++)
			{
				int x = 60;
				int y = 5 + i * 3;
				
				// Đặt màu cho hình hộp được chọn
				if (i == selectedIndex)
				{
					box(x, y, 40, 2, 10, 12, options[i]);
					selected[i] = true;
				}
				else
				{
					box(x, y, 40, 2, 10, 15, options[i]);
					selected[i] = false;
				}
			}
			
			char key = _getch();
			if (key == 72) // Phím lên
			{
				selectedIndex--;
				if (selectedIndex < 0)
				selectedIndex = MENU_SIZE - 1;
			}
			else if (key == 80) // Phím xuống
			{
				selectedIndex++;
				if (selectedIndex >= MENU_SIZE)
				selectedIndex = 0;
			}
			else if (key == 13) 
			{
				switch (selectedIndex + 1)
				{
					case 1: 
					menu1();
					break;
					case 2:
					menu2();
					break;
					case 3:
					bruteforce();
					break;
					case 4: 
					cout << "Day la bai tap cua nhom 5, goodbye nhe!\n";
					break;
				}
			}
		}
	}
	
	void menu1()
	{
		char input;
		system("cls");
		const int MENU_SIZE = 3;
		bool selected[MENU_SIZE] = {false};
		int selectedIndex = 0;
		
		// Tạo mảng chứa thông tin về các lựa chọn trong menu
		string options[MENU_SIZE] = {" 1. Encrypt", 
			" 2. Decrypt",
			" 3. Exit"};
		
		while (true)
		{
			// Vẽ menu với các lựa chọn
			for (int i = 0; i < MENU_SIZE; i++)
			{
				int x = 60;
				int y = 5 + i * 3;
				
				// Đặt màu cho hình hộp được chọn
				if (i == selectedIndex)
				{
					box(x, y, 40, 2, 10, 12, options[i]);
					selected[i] = true;
				}
				else
				{
					box(x, y, 40, 2, 10, 15, options[i]);
					selected[i] = false;
				}
			}
			
			char key = _getch();
			if (key == 72) // Phím lên
			{
				selectedIndex--;
				if (selectedIndex < 0)
				selectedIndex = MENU_SIZE - 1;
			}
			else if (key == 80) // Phím xuống
			{
				selectedIndex++;
				if (selectedIndex >= MENU_SIZE)
				selectedIndex = 0;
			}
			else if (key == 13) 
			{
				switch(selectedIndex + 1)
				{
					case 1:
					system("cls");
					encrypt();
					cout << "Ban co muon quay tro ve (y/n)?";
					cin >> input;
					if (input == 'Y' || input == 'y')
					menu1();
					else
					{
						mainpage();
					}
					cin.ignore();
					cin.get();
					break;
					case 2:
					system("cls");
					decrypt();
					cout << "Ban co muon quay tro ve (y/n)?";
					cin >> input;
					if (input == 'Y' || input == 'y')
					menu1();
					else
					{
						mainpage();
					}
					cin.ignore();
					cin.get();
					break;
					case 3:
					system("cls");
					mainpage();
					break;
				}
			}
		}
	}
	
	void menu2()
	{
		char input;
		system("cls");
		const int MENU_SIZE = 3;
		bool selected[MENU_SIZE] = {false};
		int selectedIndex = 0;
		
		// Tạo mảng chứa thông tin về các lựa chọn trong menu
		string options[MENU_SIZE] = {" 1. Encrypt", 
			" 2. Decrypt",
			" 3. Exit"};
		
		while (true)
		{
			// Vẽ menu với các lựa chọn
			for (int i = 0; i < MENU_SIZE; i++)
			{
				int x = 60;
				int y = 5 + i * 3;
				
				// Đặt màu cho hình hộp được chọn
				if (i == selectedIndex)
				{
					box(x, y, 40, 2, 10, 12, options[i]);
					selected[i] = true;
				}
				else
				{
					box(x, y, 40, 2, 10, 15, options[i]);
					selected[i] = false;
				}
			}
			
			char key = _getch();
			if (key == 72) // Phím lên
			{
				selectedIndex--;
				if (selectedIndex < 0)
				selectedIndex = MENU_SIZE - 1;
			}
			else if (key == 80) // Phím xuống
			{
				selectedIndex++;
				if (selectedIndex >= MENU_SIZE)
				selectedIndex = 0;
			}
			else if (key == 13) 
			{
				switch(selectedIndex + 1)
				{
					case 1:
					system("cls");
					AES_Ecrypt();
					cout << "Ban co muon quay tro ve (y/n)?";
					cin >> input;
					if (input == 'Y' || input == 'y')
					menu2();
					else
					{
						mainpage();
					}
					cin.ignore();
					cin.get();
					break;
					
					case 2:
					system("cls");
					AES_Decrypt();
					cout << "Ban co muon quay tro ve (y/n)?";
					cin >> input;
					if (input == 'Y' || input == 'y')
					menu2();
					else
					{
						mainpage();
					}
					cin.ignore();
					cin.get();
					break;
					case 3:
					system("cls");
					mainpage();
					break;
				}
			}
		}
	}
	
	int main(){
		system("cls");
		mainpage();
		return 0;
	}
\end{minted}